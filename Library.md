# Python-библиотека
Для взаимодействия с периферией устройства, в том числе с сервомоторами, используется предустановленная python-библиотека ```rokilowlvlpy```.

> Приведенные ниже примеры кода должны выполняться последовательно, то есть каждый следующая вставка кода является продолжением предыдущей.

Для начала работы необходимо импортировать модуль и создать объект ```Motherboard```:

```python
import rokilowlvlpy as roki

mb = roki.create_motherboard("Username")
...
```

Получим кватернион ориентации головы с инерциального датчика (IMU):

```python
...
ok, frame = mb.get_imu_latest()

if not ok:
    print(mb.get_error())
    quit()

print("Head IMU quaternion: ")
print("  x:", frame.orientation.x)
print("  y:", frame.orientation.y)
print("  z:", frame.orientation.z)
print("  w:", frame.orientation.w)
...
```

Метод ```Motherboard.get_imu_latest()``` возвращает два значения: флаг успеха и кадр IMU. Доступ к полям кадра продемонстрирован в коде выше.

Обратите внимание на то, как происходит обработка ошибок: все функции/методы библиотеки ```rokilowlvlpy``` возвращают флаг успеха в качестве первого возвращаемого значения. Если есть и другие возвращаемые значения, они идут после этого флага. В случае неудачи, строковое описание случившейся ошибки будет доступно из метода ```Motherboard.get_error()```.

> Далее для краткости будем опускать логику обработки ошибок.

Теперь провзаимодействуем с сервомоторами. Для взаимодействия с ними необходимо создать объект ```SKServo```, инкапсулирующий логику взаимодействия с сервомоторами. Также создадим переменные, в которые положим идентификаторы моторов. На устройстве "Голова робота" мотор, отвечающий за поворот головы, имеет номер *11*, а мотор, отвечающий за наклон - номер *12*.

```python
...
sks = roki.protocols.SKServo(mb)
sks.set_up_uart()

SERVO_ID_PAN = 11
SERVO_ID_TILT = 12
...
```

>Вызов функции ```sks.set_up_uart()``` является необходимым для работы. Без него контроллер материнской платы не будет знать, на какой частоте общаться с сервомоторами.

Для установки позиции сервомоторов используется функция ```sks.set_position(id, value)```. Первый аргумент - идентификатор мотора, второй - значение. Выставим нулевое положение на обоих моторах:

```python
...
sks.set_position(SERVO_ID_PAN, 0)
sks.set_position(SERVO_ID_TILT, 0)
...
```

**Важно:** аргумент ```value``` - это **не угол**. Он имеет смысл кванта поворота сервомотора, и принимает значения от *-7000* до *+7000*. Чтобы перевести значение угла в кванты сервомотора, необходимо домножить его на нормировочный коэффициент. Приведем пример функций для перевода:

```python

# Перевод из градусов
def deg2servo(deg):
  # 2^{14} / 360 = 45.51
  coeff = 2**14 / 360
  return deg * coeff

# Перевод из радиан
def rad2servo(rad):
  # 2^{14} / 2 pi = 2607
  coeff = 2**14 / (2 * 3.1415)
  return rad * coeff 
```

Также есть возможность "расслабить" сервомоторы:

```python
...
sks.set_free(SERVO_ID_TILT)
sks.set_free(SERVO_ID_PAN)
...
```

# Диагностическая утилита

Для автоматической проверки работоспособности системы можно воспользоваться утилитой командной строки ```mbdiag```, уже установленной на устройстве. Данная утилита запускает указанный набор автоматических тестов. Для того, чтобы запустить набор тестов, предназначенный для комплекта "Голова Робота", необходимо ввести команду

```bash
mbdiag head
```

В течение примерно одной минуты программа провзаимодействует с оборудованием по различным сценариям, и выведет статистику на экран.

> Комментарий: сценарий Motherboard.TestStrobeFilter является эмпирическим, поэтому он может иногда проваливаться. Это не является проблемой для работы системы.

# Драйвер материнской платы

Голова робота имеет материнскую плату, на которой расположен микрокомпьютер RaspberryPi CM4 (RPi) и внешние устройства: инерциальный датчик (IMU), камера, дисплей, а также микроконтроллер STM32, работающий в качестве связующего звена между RPi и периферией. Для управления управления прошивкой STM32 с RaspberryPi используется предустановленная утилита ```mbctl```, вызываемая из командной строки.

При запуске операционной системы **автоматически** выполняются следующие команды:

```bash
mbctl daemon start # Запуск драйвера
mbctl chip start   # Запуск прошивки микроконтроллера
```

Этой автоматической процедуры достаточно для того, чтобы можно было взаимодейстовать с периферией.

Самостоятельно использовать ```mbctl``` нужно лишь в нескольких случаях. Например, пусть вам требуется перезапустить драйвер. Это можно сделать следующим способом:

```bash
mbctl chip stop    # Остановка прошивки
mbctl daemon stop  # Остановка драйвера
mbctl daemon start
mbctl chip start
```

Также возможен сценарий, при котором вам потребуется перепрошить STM32:

```bash
mbctl chip stop    
mbctl chip flash <PATH_TO_FIRMWARE> # Прошивка
mbctl chip start
```

Остальные возможности ```mbctl``` можно узнать, введя команду

```bash
mbctl help
```
